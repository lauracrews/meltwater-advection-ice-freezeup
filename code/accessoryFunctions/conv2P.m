function c = conv2P(arg1,arg2, dim)% CONV2P	Modified two dimensional convolution.%	C = CONV2P(A, B, dim ) performs the 2-D convolution of matrices%	  A and B, returning the valid central part of the convolution in%	  the center of A, and expending the data so the edges are convolved%	  to what would be the 'valid' value. %	  (put data instead to zeros, edges acting as mirrors)%	%	Further modified to better deal with NaN :%		interpolate during convolution along dimension dim%		ignore the NaN edges (fill them in, then remove it)%		put NaN back afterwards%%  Luc Rainville 10/16/00, 08/02/01, 11/02/01[ma, na]=size(arg1);[mb, nb]=size(arg2);c = arg1;% if not specified, interpolate along the longest dimension is possibleif nargin < 3, 	dim = ((na > ma)+1); endif length(find(isnan(arg1)))==length(arg1(:))  returnendaa=isfinite(arg1);if ma>1n1=min(find(sum(aa)>0));n2=na - min(find(fliplr(sum(aa))>0))+1;elsen1=min(find(aa));n2=na - min(find(fliplr(aa)))+1;endif na>1m1=min(find(sum(aa')>0));m2=ma - min(find(fliplr(sum(aa'))>0))+1;elsem1=min(find(aa));m2=ma - min(find(fliplr(aa')))+1;endarg1 = arg1(m1:m2  , n1:n2);[ma, na]=size(arg1);% NaN buisnessi1=find(isnan(arg1));% NaN before and after - replace by that first or last value  (eventually% remove them anyway)if dim==1  x = [1:ma];  for n=1:na    i = find(isfinite(arg1(:,n)));    if length(i)>1      arg1(1:i(1),n)=arg1(i(1),n);      arg1(i(end):end,n)=arg1(i(end),n);      arg1(i(1):i(end),n) = transpose(interp1( x(i), arg1(i,n) , x(i(1):i(end))));    end  endelse  x = [1:na];  for n=1:ma    i = find(isfinite(arg1(n,:)));    if length(i)>1      arg1(n,1:i(1))=arg1(n,i(1));      arg1(n,i(end):end)=arg1(n,i(end));      arg1(n,i(1):i(end)) = interp1( x(i), arg1(n,i) , x(i(1):i(end)));    end  endendif rem(nb,2)==1		% if nb is odd;	C1=[[(nb-1)/2:-1:1] ; arg1(:,1:(nb-1)/2)];	C1=transpose(sortrows(transpose(C1),1));	C1=C1(2:end,:);		C2=[[(nb-1)/2:-1:1] ; arg1(:, end-(nb-1)/2+1 : end )];	C2=transpose(sortrows(transpose(C2),1));	C2=C2(2:end,:);	C=[C1 arg1 C2];	else			% if nb is even	C1=[[nb/2:-1:1] ; arg1(:,1:nb/2)];	C1=transpose(sortrows(transpose(C1),1));	C1=C1(2:end,:);		C2=[[nb/2:-1:1] ; arg1(:, end-nb/2+1 : end )];	C2=transpose(sortrows(transpose(C2),1));	C2=C2(2:end,:);	C=[C1 arg1 C2];endif rem(mb,2)==1		% if mb is odd;	R1=[ [(mb-1)/2:-1:1]'  C(1:(mb-1)/2 , :) ];	R1=sortrows(R1,1);	R1=R1(:,2:end);	R2=[ [(mb-1)/2:-1:1]'  C( end-(mb-1)/2+1 : end , : )];	R2=sortrows(R2,1);	R2=R2(:,2:end);	RR=[R1 ; C ; R2];else	R1=[ [mb/2:-1:1]'  C(1:mb/2 , :) ];	R1=sortrows(R1,1);	R1=R1(:,2:end);	R2=[ [mb/2:-1:1]'  C( end-mb/2+1 : end , : )];	R2=sortrows(R2,1);	R2=R2(:,2:end);	RR=[R1 ; C ; R2];endcc=conv2(RR, arg2,'valid');% interpolate to the original grid if even mb or nbif rem(nb,2)==0	x = [0.5 : 1 : na+0.5];	cc = transpose(interp1( x , transpose(cc) , [1 : na]));endif rem(mb,2)==0	x = [0.5 : 1 : ma+0.5]';	cc = interp1( x , cc , [1 : ma]');endif (m2-m1+1) ~= size(cc,1)	cc=transpose(cc);end% NaN buisnesscc(i1)=NaN;c(m1:m2  , n1:n2) = cc;